"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const message_builder_1 = require("../fb-api-helpers/message-builder");
const logger_1 = require("../logger");
class Chat {
    constructor(partnerId, sendApi, userProfileApi, askTimeout) {
        this.partnerId = partnerId;
        this.sendApi = sendApi;
        this.userProfileApi = userProfileApi;
        this.askTimeout = askTimeout;
    }
    say(text) {
        return __awaiter(this, void 0, void 0, function* () {
            this.delay && (yield this.delay);
            return yield this.sendApi.sendText(this.partnerId, text);
        });
    }
    typingOn() {
        return __awaiter(this, void 0, void 0, function* () {
            this.delay && (yield this.delay);
            return yield this.sendApi.typingOn(this.partnerId);
        });
    }
    typingOff() {
        return __awaiter(this, void 0, void 0, function* () {
            this.delay && (yield this.delay);
            return yield this.sendApi.typingOff(this.partnerId);
        });
    }
    markSeen() {
        return __awaiter(this, void 0, void 0, function* () {
            this.delay && (yield this.delay);
            return yield this.sendApi.markSeen(this.partnerId);
        });
    }
    sendImage(url, reusable = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.delay && (yield this.delay);
            return yield this.sendApi.sendImage(this.partnerId, url, reusable);
        });
    }
    sendAudio(url, reusable = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.delay && (yield this.delay);
            return yield this.sendApi.sendAudio(this.partnerId, url, reusable);
        });
    }
    sendVideo(url, reusable = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.delay && (yield this.delay);
            return yield this.sendApi.sendVideo(this.partnerId, url, reusable);
        });
    }
    sendFile(url, reusable = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.delay && (yield this.delay);
            return yield this.sendApi.sendFile(this.partnerId, url, reusable);
        });
    }
    sendMessage(messageOrBuilder) {
        return __awaiter(this, void 0, void 0, function* () {
            this.delay && (yield this.delay);
            return yield this.sendApi.send(this.partnerId, messageOrBuilder instanceof message_builder_1.MessageBuilder ?
                messageOrBuilder.build() :
                messageOrBuilder);
        });
    }
    ask(challenge, validator) {
        return __awaiter(this, void 0, void 0, function* () {
            this.delay && (yield this.delay);
            if (this.responder) {
                logger_1.default.warn("couldn't ask again over previous asking that is not yet answered");
                return Promise.reject("previous asking not answered yet");
            }
            yield this.say(challenge);
            return Promise.race([
                new Promise((resolve, reject) => {
                    this.responder = { resolve, reject, validator, challenge };
                }),
                new Promise((resolve, reject) => {
                    const id = setTimeout(() => {
                        clearTimeout(id);
                        this.responder = undefined;
                        reject({ message: "ask expired", data: challenge });
                    }, this.askTimeout);
                })
            ]);
        });
    }
    askWithMessage(messageOrBuilder, validator) {
        return __awaiter(this, void 0, void 0, function* () {
            this.delay && (yield this.delay);
            const challenge = messageOrBuilder = messageOrBuilder instanceof message_builder_1.MessageBuilder ? messageOrBuilder.build() : messageOrBuilder;
            if (this.responder) {
                logger_1.default.warn("couldn't ask again over previous asking that is not yet answered");
                return Promise.reject("previous asking not answered yet");
            }
            yield this.sendMessage(challenge);
            return Promise.race([
                new Promise((resolve, reject) => {
                    this.responder = { resolve, reject, validator, challenge };
                }),
                new Promise((resolve, reject) => {
                    const id = setTimeout(() => {
                        clearTimeout(id);
                        this.responder = undefined;
                        reject({ message: "ask expired", data: "<structured message>" });
                    }, this.askTimeout);
                })
            ]);
        });
    }
    answer(data, chatService) {
        if (!chatService) {
            throw new Error("unauthorized calling of the Chat.answer");
        }
        if (this.responder) {
            if (typeof data === "string" && this.responder.validator && !this.responder.validator(data)) {
                logger_1.default.debug("input validation failed, repeating the challenge");
                if (typeof this.responder.challenge === "string") {
                    this.say(this.responder.challenge);
                }
                else {
                    this.sendMessage(this.responder.challenge);
                }
            }
            else {
                logger_1.default.debug("the question asked has been answered");
                this.responder.resolve(data);
                this.responder = undefined;
            }
            return true;
        }
        return false;
    }
    getUserProfile() {
        return this.userProfileApi.getUserProfile(this.partnerId);
    }
    getPartnerId() {
        return this.partnerId;
    }
    wait(seconds) {
        this.delay = new Promise((resolve) => {
            setTimeout(() => {
                this.delay = undefined;
                resolve();
            }, seconds * 1000);
        });
        return this;
    }
}
exports.Chat = Chat;
