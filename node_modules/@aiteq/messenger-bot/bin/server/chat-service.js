"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fb_api_1 = require("../fb-api");
const logger_1 = require("../logger");
const chat_1 = require("./chat");
const router_service_1 = require("./router-service");
class ChatService extends router_service_1.RouterService {
    constructor(accessToken, askTimeout) {
        super();
        this.accessToken = accessToken;
        this.askTimeout = askTimeout;
        this.hearHandlers = new Array();
        this.chats = new Map();
        this.sendApi = new fb_api_1.Send.Api(accessToken);
        this.userProfileApi = new fb_api_1.UserProfile.Api(accessToken);
        this.post("/", (req, res, next) => {
            logger_1.default.debug("webhook post request received:", JSON.stringify(req.body));
            logger_1.default.debug("returning 200 OK");
            res.status(200).end();
            if (!req.body.object || req.body.object !== "page" || !req.body.entry) {
                throw new Error("unknown request");
            }
            req.body.entry.forEach((entry) => {
                logger_1.default.info(`received meesage for page https://www.facebook.com/${entry.id}`);
                entry.messaging.forEach((item) => {
                    const chat = this.chats.get(item.sender.id) || (() => {
                        const newChat = new chat_1.Chat(item.sender.id, this.sendApi, this.userProfileApi, this.askTimeout);
                        this.chats.set(item.sender.id, newChat);
                        return newChat;
                    })();
                    if (item.message) {
                        if (item.message.quick_reply) {
                            this.processQuickReply(item.message, chat);
                        }
                        else if (item.message.text) {
                            this.processTextMessage(item.message, chat);
                        }
                        else if (item.message.attachments) {
                            this.processAttachment(item.message, chat);
                        }
                        else if (item.message.is_echo) {
                            this.processEcho(item.message, chat);
                        }
                        else {
                            logger_1.default.warn("received an unknown message item", item);
                        }
                    }
                    else if (item.delivery) {
                        this.processDelivery(item.delivery, chat);
                    }
                    else if (item.read) {
                        this.processRead(item.read, chat);
                    }
                    else if (item.postback) {
                        this.processPostback(item.postback, chat);
                    }
                    else {
                        logger_1.default.warn("received an unknown message item", item);
                    }
                });
            });
        });
    }
    hear(hooks, handler) {
        hooks.forEach((hook) => {
            logger_1.default.info("subscribing to text", hook);
            this.hearHandlers.push({ hook, handler });
        });
        return this;
    }
    processTextMessage(message, chat) {
        logger_1.default.debug("received TEXT message", message.mid);
        if (!chat.answer(message.text, this)) {
            this.hearHandlers.forEach((hh) => {
                const matches = hh.hook.exec(message.text);
                if (matches) {
                    logger_1.default.debug("calling hearing handler", hh.hook);
                    hh.handler(chat, message.text, matches.slice(1));
                }
            });
            this.emit(fb_api_1.Webhook.Event.TEXT_MESSAGE, chat, message.text);
        }
    }
    processAttachment(message, chat) {
        logger_1.default.debug("received ATTACHMENT message", message.mid);
        message.attachments.forEach((attachment) => {
            let data;
            switch (attachment.type) {
                case fb_api_1.Webhook.AttachmentType.IMAGE:
                case fb_api_1.Webhook.AttachmentType.AUDIO:
                case fb_api_1.Webhook.AttachmentType.VIDEO:
                case fb_api_1.Webhook.AttachmentType.FILE:
                    logger_1.default.debug("received MEDIA message", attachment.payload.url);
                    data = attachment.payload.url;
                    break;
                case fb_api_1.Webhook.AttachmentType.LOCATION:
                    logger_1.default.debug("received LOCATION message", attachment.title, attachment.payload.coordinates);
                    data = attachment;
                    break;
                default:
                    data = attachment;
                    break;
            }
            this.emit(`${fb_api_1.Webhook.Event.ATTACHMENT}:${attachment.type}`, chat, data);
            this.emit(fb_api_1.Webhook.Event.ATTACHMENT, chat, data);
        });
    }
    processPostback(postback, chat) {
        const payload = JSON.parse(postback.payload);
        logger_1.default.debug("recieved POSTBACK from", payload.src, payload.id);
        payload.id && this.emit(`${fb_api_1.Webhook.Event.POSTBACK}:${payload.src}:${payload.id}`, chat, payload.data);
        this.emit(`${fb_api_1.Webhook.Event.POSTBACK}:${payload.src}`, chat, payload.data);
        this.emit(fb_api_1.Webhook.Event.POSTBACK, chat, payload.data);
    }
    processQuickReply(message, chat) {
        logger_1.default.debug("received QUICK REPLY message", message.mid);
        const payload = JSON.parse(message.quick_reply.payload);
        if (!chat.answer(payload.data ? payload : payload.id, this)) {
            this.emit(`${fb_api_1.Webhook.Event.TEXT_QUICK_REPLY}:${payload.id}`, chat, payload.data);
            this.emit(fb_api_1.Webhook.Event.TEXT_QUICK_REPLY, chat, payload.data);
        }
    }
    processEcho(message, chat) {
        logger_1.default.debug("received ECHO for", message.mid);
        this.emit(fb_api_1.Webhook.Event.MESSAGE_ECHO, chat, message);
    }
    processDelivery(delivery, chat) {
        logger_1.default.debug("received DELIVERY confirmations for", (delivery.mids || []).join(","));
        this.emit(fb_api_1.Webhook.Event.MESSAGE_DELIVERED, chat, delivery);
    }
    processRead(read, chat) {
        logger_1.default.debug("received READ confirmation to time", read.watermark);
        this.emit(fb_api_1.Webhook.Event.MESSAGE_READ, chat, read);
    }
}
exports.ChatService = ChatService;
