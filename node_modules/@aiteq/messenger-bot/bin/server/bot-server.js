"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const bodyParser = require("body-parser");
const crypto = require("crypto");
const express = require("express");
const http = require("http");
const fb_api_1 = require("../fb-api");
const logger_1 = require("../logger");
const chat_service_1 = require("./chat-service");
const extensions_service_1 = require("./extensions-service");
const ping_service_1 = require("./ping-service");
const verification_service_1 = require("./verification-service");
class BotServer {
    constructor(config) {
        this.config = config;
        this.verifyRequest = (req, res, buf, encoding) => {
            const [algorithm, signature] = (req.headers["x-hub-signature"] || "").split("=");
            if (!signature) {
                throw new Error("couldn't validate the request signature, the 'x-hub-signature' header not found");
            }
            if (signature !== crypto.createHmac(algorithm, this.config.appSecret).update(buf).digest("hex")) {
                throw new Error("request's signature is not valid");
            }
            logger_1.default.debug("request signature verified");
        };
        config.webhookPath = config.webhookPath || "/webhook";
        config.extensionsPath = config.extensionsPath || "/ext";
        config.pingPath = config.pingPath || "/ping";
        config.name = config.name || "noname";
        config.askTimeout = config.askTimeout || (1000 * 60 * 5);
        logger_1.default.level = config.logLevel || logger_1.default.level;
        this.profileApi = new fb_api_1.MessengerProfile.Api(this.config.accessToken);
        this.subscriptionsApi = new fb_api_1.Subscriptions.Api(this.config.accessToken, this.config.appSecret);
        this.callbackUrl = this.subscriptionsApi.getCallbackUrl(fb_api_1.Subscriptions.SubscriptionTopic.PAGE);
        this.app = express();
        this.app.set("view engine", "ejs");
        this.app.use("/static", express.static("public"));
        this.app.use(bodyParser.json({ verify: this.verifyRequest }));
        this.app.use(bodyParser.urlencoded({ extended: false }));
        this.app.use(this.config.webhookPath, new verification_service_1.VerificationService(this.config.verifyToken).getRouter());
        logger_1.default.info("VerificationService has been attached to", this.config.webhookPath);
        this.chatService = new chat_service_1.ChatService(this.config.accessToken, this.config.askTimeout);
        this.app.use(this.config.webhookPath, this.chatService.getRouter());
        logger_1.default.info("ResponderService has been attached to", this.config.webhookPath);
        this.extensions = new extensions_service_1.ExtensionsService();
        this.app.use(this.config.extensionsPath, this.extensions.getRouter());
        logger_1.default.info("ExtensionService has been attached to", this.config.extensionsPath);
        this.app.use(this.config.pingPath, new ping_service_1.PingService().getRouter());
        logger_1.default.info("PingService has been attached to", this.config.pingPath);
        process.on("unhandledRejection", (error) => {
            if (error.message === "ask expired") {
                logger_1.default.debug("unanswered question:", error.data);
            }
            else {
                logger_1.default.error("unhandledRejection:", error.message);
            }
        });
    }
    static normalizePort(value) {
        const port = (typeof value === "string") ? parseInt(value, 10) : value;
        return isNaN(port) ? value : (port >= 0 ? port : false);
    }
    static regExpEscape(text) {
        return text.replace(BotServer.RE_ESCAPE, "\\$&");
    }
    start() {
        const port = BotServer.normalizePort(this.config.port || process.env.PORT || 8080);
        this.app.set("port", port);
        this.server = http.createServer(this.app)
            .on("error", (error) => {
            const bind = (typeof port === "string") ? "pipe " + port : "port " + port;
            switch (error.code) {
                case "EACCES":
                    throw new Error(`BotServer[${this.config.name}] not started. ${bind} requires elevated privileges.`);
                case "EADDRINUSE":
                    throw new Error(`BotServer[${this.config.name}] not started. ${bind} is already in use.`);
                default:
                    throw error;
            }
        })
            .on("listening", () => {
            const addr = this.server.address();
            const bind = (typeof addr === "string") ? `pipe ${addr}` : `port ${addr.port}`;
            logger_1.default.info(`BotServer[${this.config.name}] is listening on ${bind}`);
        })
            .listen(port);
    }
    stop() {
        this.server.close();
    }
    hear(hooks, callback) {
        let regexps;
        if (typeof hooks === "string") {
            regexps = [new RegExp(`^${BotServer.regExpEscape(hooks)}$`, "i")];
        }
        else if (Array.isArray(hooks)) {
            regexps = hooks.map((hook) => {
                return typeof hook === "string" ? new RegExp(`^${BotServer.regExpEscape(hook)}$`, "i") : hook;
            });
        }
        else {
            regexps = [hooks];
        }
        this.chatService.hear(regexps, callback);
        return this;
    }
    on(event, idOrCallback, callback) {
        let extEvent = event;
        if (typeof idOrCallback === "string") {
            extEvent += ":" + idOrCallback;
        }
        else {
            callback = idOrCallback;
        }
        logger_1.default.info("subscribing to event", extEvent);
        this.chatService.on(extEvent, callback);
        return this;
    }
    addChatExtension(extension) {
        (() => __awaiter(this, void 0, void 0, function* () { return extension.setBaseUrl(yield this.callbackUrl); }))();
        this.extensions.addExtension(extension);
        return this;
    }
}
BotServer.RE_ESCAPE = RegExp("[" + "-[]/{}()*+?.\\^$|".split("").join("\\") + "]", "g");
exports.BotServer = BotServer;
